# -*- coding: utf-8 -*-
"""
Created on Mon Nov 24 16:28:05 2025

@author: 33782
"""


import numpy as np
import matplotlib.pyplot as plt
import numba
from skimage.segmentation import find_boundaries

'''
RAJOUTER LES TYPPES, pour pouvoir afficher avec plot_types
rendre le code lislble
les divisons selon un axe aléatoire passant par le CM

'''



#%%

N = 100
J_11 = 2
J_10 = 1
T_boltz = 10.0
lbda = 1.0
Vol_cible_init = 150
aire_max = 210  # threshold pour division
ratio_air_perimetre = 5


#%%

num_map = np.zeros((N, N), dtype=np.int32)
Vol_cible_list = [Vol_cible_init]  # Volume cible pour les cellules (index k -> cell numero k+1)

compteur_cell = 1  # nb de cellules

#%%

# @numba.njit
def init():
    cx, cy = N // 2, N // 2
    # num_cell = 1
    rr = 4
    for i in range(-rr, rr+1):
        for j in range(-rr, rr+1):
            x, y = cx+i, cy+j
            if (i*i + j*j) <= rr*rr:
                num_map[x,y] = 1
    
    

init()

plt.imshow(num_map)
plt.show()


#%%s

def plot_type(num_map, time = None):
    type_map = (num_map != 0).astype(int)
    border_color = 2  
    borders = find_boundaries(num_map, mode='inner')

    # conversion en float pour éviter les saturations quand on additionne
    img = type_map.astype(float).copy()
    img[borders] = border_color  # surimpression des bordures

    plt.imshow(img, cmap='inferno', interpolation='nearest')
    if time is not None:
        plt.title(f"t = {time}")
    plt.axis('off')
    plt.show()



#%%

@numba.njit
def centre_mass_tumeur(num_map):
    '''
    renvoie le centre de masse de la tumeur
    '''
    compteur = 0
    numerateur = np.zeros(2)
    for i in range(N):
        for j in range(N):
            if num_map[i,j] != 0:
                numerateur[0] += i
                numerateur[1] += j
                compteur += 1    
                
    return numerateur/compteur
    
@numba.njit
def centre_mass_cell(num_map, num_cell):
    compteur = 0
    numerateur = np.zeros(2)
    for i in range(N):
        for j in range(N):
            if num_map[i, j] == num_cell:
                numerateur[0] += i
                numerateur[1] += j
                compteur += 1
    
    if compteur == 0:
        # la cellule a disparue...
        return np.array([np.nan, np.nan])
    
    return numerateur / compteur

#%%

@numba.njit
def aire_cellule_i(num_map, cell_num):
    aire = 0
    for i in range(N):
        for j in range(N):
            if num_map[i,j] == cell_num:
                aire += 1
    return aire



@numba.njit
def perimetre_cellule_i(num_map, num_cell):
    
    perimetre = 0
    
    for i in range(N):
        for j in range(N):
            if num_map[i,j] == num_cell:
                voisins = [(i+1,j), (i-1,j), (i,j+1), (i,j-1)] #A EAJOUTER : CLP !!!!!! PAS IMPORTAT POUR INSTANNT...
                for ni, nj in voisins:
                    if num_map[ni, nj] != num_cell:
                        perimetre += 1
                        break  # un voisin différent suffit pour compter le pixel comme bord
    return perimetre




#%%


aire_max = 150  #ritère à revoir...


@numba.njit       #VERIFER OIURQUOI NULBA NE LARCHE PAS
def dois_je_me_diviser(num_map_local, num_cell):
    aire = aire_cellule_i(num_map_local, num_cell)
    perimetre = perimetre_cellule_i(num_map, num_cell)
    
    if perimetre != 0:
        ratio = aire/perimetre
        if ratio >= ratio_air_perimetre:
            return True
    
    return False


print(dois_je_me_diviser(num_map, 1))

#%%


# @numba.njit
# def division_cell_axis(num_map, num_cell, Vol_cible_list, Vol_cible_init, compteur_cell):
#     """
#     Divise la cellule num_cell en deux selon l'axe passant par son centre de masse.
#     Renvoie num_map, Vol_cible_list et compteur_cell mis à jour.
#     """
#     CM = centre_mass_cell(num_map, num_cell)

#     # si cellule vide, rien à faire
#     if np.isnan(CM[0]):
#         return num_map, Vol_cible_list, compteur_cell

#     new_id = compteur_cell + 1
#     for i in range(N):
#         for j in range(N):
#             if num_map[i, j] == num_cell:
#                 if i > CM[0]:
#                     num_map[i, j] = new_id

#     # Mettre à jour Vol_cible_list
#     Vol_cible_list[num_cell - 1] = Vol_cible_init
#     Vol_cible_list.append(Vol_cible_init)

#     compteur_cell += 1
#     return num_map, Vol_cible_list, compteur_cell

@numba.njit
def droite_tiree_aleat(x, alpha, X_CM, Y_CM):
    return alpha * (x - X_CM) + Y_CM


@numba.njit
def division_cell_axis_aleat(num_map, num_cell, Vol_cible_list, Vol_cible_init, compteur_cell):
    """
    Divise la cellule num_cell en deux selon l'axe passant par son centre de masse.
    Renvoie num_map, Vol_cible_list et compteur_cell mis à jour.
    """
    CM = centre_mass_cell(num_map, num_cell)

    # si cellule vide, rien à faire
    if np.isnan(CM[0]):
        return num_map, Vol_cible_list, compteur_cell

    new_id = compteur_cell + 1
    
    alpha_aleat = np.random.uniform(-np.pi, np.pi)
    
    for i in range(N):
        for j in range(N):
            if num_map[i, j] == num_cell:
                if droite_tiree_aleat(i, np.tan(alpha_aleat), CM[0], CM[1]) < j:
                    num_map[i, j] = new_id

    # Mettre à jour Vol_cible_list
    Vol_cible_list[num_cell - 1] = Vol_cible_init
    Vol_cible_list.append(Vol_cible_init)

    compteur_cell += 1
    return num_map, Vol_cible_list, compteur_cell



#%%

# @numba.jit
# def J(num_cell, num_voisin):
#     num_cell, num_voisin =  int(num_cell), int(num_voisin)
    
#     if num_cell == num_voisin:
#         return 0
    
#     elif num_cell == 0:
#         return J_10
    
#     else:
#         if num_voisin == 0:
#             return J_10
#         else:
#             return J_11

@numba.njit
def J(num_cell, num_voisin):
    # 0 si identique
    if num_cell == num_voisin:
        return 0
    # si une dess deux est le milieu:
    if num_cell == 0 or num_voisin == 0:
        return J_10
    # sinon, 2 cell différentes
    return J_11


#%%


@numba.jit
def increase_temps(num_map, nb_change, Vol_cible_list, compteur_cell, T=T_boltz, lbda=lbda):
    voisins_numero = [(1,0),(-1,0),(0,1),(0,-1), (1,1), (-1,-1), (1,-1), (-1,1)]

    # 1 : vérifier les divisions
    for n in range(1, compteur_cell + 1):
        if dois_je_me_diviser(num_map, n):
            num_map, Vol_cible_list, compteur_cell = division_cell_axis_aleat(
                num_map, n, Vol_cible_list, Vol_cible_init, compteur_cell
            )

    # 2 : Monte Carlo
    for _ in range(nb_change):
        i, j = np.random.randint(0, N, 2)
        num_old = num_map[i, j]
        di, dj = voisins_numero[np.random.randint(0, 8)]
        ni, nj = (i + di) % N, (j + dj) % N
        num_new = num_map[ni, nj]

        if num_old == num_new:
            continue

        # Energie d’interaction
        dE_int = 0
        for dx, dy in voisins_numero:
            xi, xj = (i + dx) % N, (j + dy) % N
            num_voisin = num_map[xi, xj]
            dE_int += J(num_new, num_voisin) - J(num_old, num_voisin)

        # Energie de volume
        V_c = np.array([np.sum(num_map == k) for k in range(1, compteur_cell + 1)])
        dV = np.zeros_like(V_c)
        if num_old > 0:
            dV[num_old - 1] -= 1
        if num_new > 0:
            dV[num_new - 1] += 1

        Vol_cible = np.array(Vol_cible_list[:compteur_cell])
        dE_vol = lbda * np.sum((V_c + dV - Vol_cible)**2 - (V_c - Vol_cible)**2)

        # Metropolis
        dE = dE_int + dE_vol
        if dE <= 0 or np.random.rand() < np.exp(-dE / T):
            num_map[i, j] = num_new

    return num_map, Vol_cible_list, compteur_cell
#%%


num_map = np.zeros((N, N), dtype=np.int32)
Vol_cible_list = [Vol_cible_init]  # vol cible de la première cellule

init()


compteur_cell = 1  #Compteur cell aura len(types) contenant le nb de chaque type dedans


#%%


def defiler_temps(nb_temps):
    global num_map, Vol_cible_list, compteur_cell
    for aaa in range(nb_temps):
        num_map, Vol_cible_list, compteur_cell = increase_temps(num_map, N**2, Vol_cible_list, compteur_cell)
        if aaa % 1 == 0:
            plt.imshow(num_map, cmap='inferno')
            plt.show()
            # plot_type(num_map, time = aaa)

defiler_temps(100)
        

# M = initial_state_n_rond()

# def def_temp(M, nb_pas):
#     M = np.copy(M)
#     # summ = np.zeros(nb_pas)
#     for i in range(nb_pas):
#         increase_temps(M, 10)
#         # summ[i] = np.sum(M)
#         if i % 10000 == 0:
#             plot_type(M, time = i)
#             # plot_num(M, time = i)
#     # plt.plot(np.arange(0,nb_pas, 1), summ)
#     # plt.xlabel('temps')
#     # plt.ylabel('nombre de pixels 1')
        
# def_temp(M, 100000)












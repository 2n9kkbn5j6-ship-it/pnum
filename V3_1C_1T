# -*- coding: utf-8 -*-
"""
Created on Wed Nov  5 13:31:53 2025

@author: 33782
"""

import numpy as np
import matplotlib.pyplot as plt


#%% Les variables

N = 100        #Cote de la matrice
T_boltz = 1
J_10 = 1
lbda = 0.5
V_cible = 2000




#%% Les conditions initiales

def initial_state_carre():
    '''

    Returns
    -------
    Une matrice de 0 de taille N avec un carre de 1 au centre
    '''

    M = np.zeros((N, N))
    M[30:70, 20:70] = 1

    return M

def initial_state_aleat(n):
    '''
    Parameters
    ----------
    M=n : TYPE: int
        le nombre de points 1 au départ

    Returns
    -------
    M : Matrice NxN
        avec n points 1, sinon 0 partout

    '''
    M = np.zeros((N, N))
    couple_change = np.random.randint(0,N, (n,2))
    for elt in couple_change:
        M[elt[0], elt[1]] = 1
    return M

def initial_state_rond(r):
    M = np.zeros((N, N))
    centre_x, centre_y = int(N/2), int(N/2)

    for i in range(N):
        for j in range(N):
            if np.sqrt((i - centre_x)**2 + (j - centre_y)**2) <= r:
                M[i,j] = 1

    return M

#%%

def Energie_tot(M, J=J, lbda=lbda, V_cible=V_cible):
    '''
    Parameters
    ----------
    M : TYPE: Matrice NxN
        La matrice de départ
    J : float, optional
        L'énergie d'interface. The default is J.
    lbda : float, optional
        l'énergie de contrainte de volume. The default is lbda.
    V_cible : float, optional
        Lz volume cible. The default is V_cible.

    Returns
    -------
    Float
    L'énergie totale de la matrice M'

    '''
    v_cell = np.sum(M)    #A VERIFIER? COMMENT DETEMRINER CE VOLUME

    up, down, left, right = np.roll(M, -1, axis=0), np.roll(M,  1, axis=0), np.roll(M, -1, axis=1), np.roll(M,  1, axis=1)
    # contient dans l'ordre M[i+1, j] M[i-1, j]  M[i, j+ 1] M[i, j-1] , pour calculer les interfaces

    # Interface = somme des différences absolues locales
    interface = np.sum(np.abs(M - up) + np.abs(M - down) + np.abs(M - left) + np.abs(M - right))

    # On divise par 2 car chaque interface est comptée 2 fois
    return J * interface / 2 + lbda * (v_cell - V_cible)**2





#%%


def J(a,b):
    if (a,b) in [(0,1),(1,0)]: return J_10
    return 0




def increase_temps(M, nb_change, J = J, lbda=lbda, V_cible=V_cible):
    '''
    Parameters
    ----------
    M : matrice, de taille NxN
        La matrice de laquelle on part
    nb_change : int
        Le nombre de changements par pas de temps

    Returns
    -------
    M : matrice, de taille NxN
        La MEME matrice, avec modifications eventuellement

    '''
    for _ in range(nb_change):
        i, j = np.random.randint(0, N, 2) #l'indice de la matrice à changer


        val_old = M[i,j]   #Au lieu de faire une copie de toute ma matrice avec np.copy, je fais juste une copie de l'élément intéresant
        val_new = 1 - val_old

        voisins = [M[(i+1)%N, j], M[(i-1)%N, j], M[i, (j+1)%N], M[i, (j-1)%N]] #Pareil pour l'interfaace, je n'ai pas besoi de tout reclculer, mais uste localement

        dE_int = 0
        for v in voisins:
            dE_int += J(val_new, v) - J(val_old, v)



        # voisins = M[(i+1)%N, j] + M[(i-1)%N, j] + M[i, (j+1)%N] + M[i, (j-1)%N] #Pareil pour l'interfaace, je n'ai pas besoi de tout reclculer, mais uste localement
        #CLP, pour ne pas s'embéter avec les bords

        dV1 = (1 if val_new == 1 else 0) - (1 if val_old == 1 else 0)
        V1 = np.sum(M == 1)
        dE_vol = lbda * ((V1 + dV1 - V_cible)**2 - (V1 - V_cible)**2)


        # if val_old == 0:
        #     dE_int = J * (4 - 2 * voisins)
        #     # nb_interface_old = voisins
        #     # nb_interface_new = 4 - voisins
        #     # dE_int = J * (nb_interface_new - nb_interface_old)    # La logique m'est apparue tard, à vérifier...
        # else:
        #     dE_int = - J * (4 - 2 * voisins)

        #     # nb_interface_new = voisins
        #     # nb_interface_old = 4 - voisins
        #     # dE_int = J * (nb_interface_new - nb_interface_old)
        dE = dE_vol + dE_int

        if dE <= 0 or np.random.rand() < np.exp(-dE / T_boltz): #Metropolis (cf cours M1 C)
            M[i,j] = val_new  # accepter

    return M




#%%

# M = initial_state_aleat(6000)
M = initial_state_carre()
# M = initial_state_rond(25)
plt.imshow(M)



#%%

def def_temp(M, nb_pas):
    M = np.copy(M)
    summ = np.zeros(nb_pas)
    for i in range(nb_pas):
        increase_temps(M, 10)
        summ[i] = np.sum(M)
        if i % 100 == 0:
            plt.imshow(M)
            plt.title(i)
            plt.axis('off')
            plt.show()
    # plt.plot(np.arange(0,nb_pas, 1), summ)
    # plt.xlabel('temps')
    # plt.ylabel('nombre de pixels 1')

def_temp(M, 10000)


#%%

def ddphi_lbda_J(lbda_min, lbda_max, J_min, J_max, lbda_step, J_step, nb_pas):
    J_list = np.arange(J_min, J_max, J_step)
    # print(len(J_list))
    Lbda_list = np.arange(lbda_min, lbda_max, lbda_step)
    # print(len(Lbda_list))

    ddphi = np.zeros((len(Lbda_list), len(J_list)))

    for i in range(len(Lbda_list)):
        for j in range(len(J_list)):
            M = initial_state_carre()
            for a in range(nb_pas):
                increase_temps(M, 10)
            ddphi[i,j] += np.sum(M)

    plt.imshow(ddphi)
    plt.xlabel('lambda')
    plt.ylabel('J')
    plt.title(f'nombre de pixels 1 au bout de t = {nb_pas}')
    plt.axis('off')
    plt.colorbar()
    plt.show()
    return ddphi

A = ddphi_lbda_J(0.1, 10, 0.1, 10, 1, 1, 500)


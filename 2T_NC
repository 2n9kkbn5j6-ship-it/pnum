# -*- coding: utf-8 -*-
"""
Created on Thu Nov 13 11:03:11 2025

@author: 33782
"""

import numpy as np
import matplotlib.pyplot as plt
import numba
from skimage.segmentation import find_boundaries






#%%

N = 100        #Cote de la matrice
n1 = 50     #nb de cellules de type 1 simulées
n2 = 20
T_boltz = 10
J_11 = 2
J_10 = 16
J_12 = 11
J_20 = 40
J_22 = 14
lbda = 1
V_cible_1 = np.zeros(n1) + 55
V_cible_2 = np.zeros(n2) + 50
V_cible = np.concatenate((V_cible_1, V_cible_2))

# J_matrix = np.zeros((n + 1, n + 1))

# # Définition de la matrice des j
# for i in range(1, n + 1):
#     J_matrix[i, 0] = J_10
#     J_matrix[0, i] = J_10
#     for j in range(1, n + 1):
#         if i != j:
#             J_matrix[i, j] = J_11


#%%

def plot_type(M, time=None, cmap='gray'):
    border_color = np.max(M[:,:,0]) + 1
    a = M[:, :, 1]  
    borders = find_boundaries(a, mode='inner')

    img = M[:, :, 0].astype(float).copy()
    img[borders] = border_color  # surimpression des bordures

    plt.imshow(img, cmap=cmap, interpolation='nearest')
    if time is not None:
        plt.title(f"t = {time}")
    plt.axis('off')
    plt.show()

# def plot_type(M, time=None, cmap='gray'):
#     types = M[:,:,0]
#     numbers = M[:,:,1]

#     borders = find_boundaries(numbers, mode='inner') #Limites ente cellules

#     plt.imshow(types, cmap=cmap, interpolation='nearest')
#     plt.contour(borders.astype(float), levels=[0.5], colors='black', linewidths=0.5)

#     if time is not None:
#         plt.title(f"t = {time}")
#     plt.axis('off')
#     plt.tight_layout()
#     plt.show()


# def plot_type(M, time=None, cmap='gray'):
#     types = M[:,:,0].astype(float)
#     numbers = M[:,:,1]

#     # Bordures entre cellules
#     borders = find_boundaries(numbers, mode='inner')

#     # --- Création d’une image couleur indépendante du type ---
#     img = plt.cm.get_cmap(cmap)(types / types.max())

#     # --- On remplace les pixels de frontière par du noir (ou blanc) ---
#     # Noir net
#     img[borders] = [0, 0, 0, 0.6]
#    # RGBA

#     plt.imshow(img, interpolation='nearest')

#     if time is not None:
#         plt.title(f"t = {time}")

#     plt.axis('off')
#     plt.tight_layout()
#     plt.show()





def plot_num(M, time = None):
    plt.imshow(M[:,:,1], cmap = 'magma')
    if time is not None:
        plt.title(f"t = {time}")
    plt.axis('off')
    # plt.colorbar()
    plt.show()



#%%

@numba.njit
def initial_state_n_rond(M, n, type_cellule, V_cible):
    R = np.abs((((3 * V_cible) / (4 * np.pi)) ** (1/3) + np.random.normal(0, 5, n)).astype(np.int32)) 
    # print(R)
    
    Centres = np.random.randint(int(N/5),int(4*N/5),(n,2))

    for cell_num in range(n):  
        for i in range(N):
            for j in range(N):
                if np.sqrt((i - Centres[cell_num,0])**2 + (j - Centres[cell_num,1])**2) <= R[cell_num]:
                    M[i,j,0] = int(type_cellule)    #Type numéro type_cell
                    M[i,j,1] = int(cell_num) + 1  #cellule numéro cell num + 1
                
    return M


def initial_state_smart(M, n, type_cellule):
    
    Centres = np.random.randint(int(N/5),int(4*N/5),(n,2))

    rr = 4
    for cell_num in range(n):
        cell_num = int(cell_num)
        cx, cy = Centres[cell_num, 0], Centres[cell_num, 1]
        for i in range(-rr, rr+1):
            for j in range(-rr, rr+1):
                x, y = cx+i, cy+j
                if (i*i + j*j) <= rr**2:
                    M[x,y,0] = type_cellule
                    M[x,y,1] = cell_num + 1
      
    return M

    # for cell_num in range(n):  
    #     for i in range(N):
    #         for j in range(N):
    #             if np.sqrt((i - Centres[cell_num,0])**2 + (j - Centres[cell_num,1])**2) <= R[cell_num]:
    #                 M[i,j,0] = int(type_cellule)    #Type numéro type_cell
    #                 M[i,j,1] = int(cell_num) + 1  #cellule numéro cell num + 1



M = np.zeros((N, N, 2), dtype=np.int32)

# M = initial_state_n_rond(M, n1, 1, V_cible_1)
# M = initial_state_n_rond(M, n2, 2, V_cible_2) 
M = initial_state_smart(M, n1, 1)
M = initial_state_smart(M, n2, 2)
# plt.imshow(M[:,:,0])
plot_type(M, time = None, cmap = 'inferno')
# plot_num(M)


#%%
@numba.njit
def coupling_neighborhood(M, i, j):
    return np.array([M[(i+1)%N, j], M[(i-1)%N, j], M[i, (j+1)%N], M[i, (j-1)%N]])

@numba.njit
def target_neighborhood(M, i, j):
    return np.array([M[(i+1)%N, j], M[(i-1)%N, j], M[i, (j+1)%N], M[i, (j-1)%N], 
                     M[(i+1)%N, (j-1)%N], M[(i-1)%N, (j-1)%N], M[(i+1)%N, (j+1)%N], M[(i-1)%N, (j+1)%N]])


#%% Je sotcke les valeurs du volume pou ne paas avoir à les recalculer à chaque fois

V_c = np.zeros(n1+n2, dtype=np.int32)

for i in range(N):
    for j in range(N):
        num = M[i,j,1]
        if num > 0:
            idx = num-1 if M[i,j,0] == 1 else n1+num-1
            V_c[idx] += 1



#%%
J_matrice = np.array([[0, J_10, J_20],
                      [J_10, J_11, J_12],
                      [J_20, J_12, J_22]])

@numba.njit
def J(type_cell, num_cell, type_voisin, num_voisin):                # A vérifier
    type_cell, type_voisin = int(type_cell), int(type_voisin)
    if type_cell != type_voisin :
        return J_matrice[type_cell, type_voisin]
    elif num_cell != num_voisin :
        return J_matrice[type_cell, type_voisin]
        
    return 0
#%%

voisins_numero = np.array([(1,0),(-1,0),(0,1),(0,-1), (1,1), (-1,-1), (1,-1), (-1,1)])

@numba.njit
def dE_surf_local(M,i,j, type_old, num_old, type_new, num_new):
    dE_int = 0
    for (dx, dy) in voisins_numero: 
        xi, xj = (i + dx) % N, (j + dy) % N #Les indices, avec CLP
        type_voisin, num_voisin = M[xi, xj, :]
        E_avant = J(type_old, num_old, type_voisin, num_voisin)
        E_apres = J(type_new, num_new, type_voisin, num_voisin)
            
        dE_int += (E_apres - E_avant)
    
    return dE_int


@numba.njit
def dE_volume_local(V_c, V_cible, type_old, num_old, type_new, num_new):
    dE = 0.0

    if num_old > 0:
        if type_old == 1:
            idx_old = num_old - 1
        else:
            idx_old = n1 + num_old - 1
        V_before = V_c[idx_old]
        dE += (V_before - 1 - V_cible[idx_old])**2 - (V_before - V_cible[idx_old])**2

    if num_new > 0:
        if type_new == 1:
            idx_new = num_new - 1
        else:
            idx_new = n1 + num_new - 1
        V_before = V_c[idx_new]
        dE += (V_before + 1 - V_cible[idx_new])**2 - (V_before - V_cible[idx_new])**2

    return lbda * dE
    



#%%




@numba.njit
def increase_temps(M, V_c, nb_change, T=T_boltz, V_cible=V_cible):
    """
    Effectue `nb_change` tentatives Metropolis sur la matrice M,
    met à jour M et V_c en place et renvoie (M, V_c).
    """

    for _ in range(nb_change):

        i, j = np.random.randint(0, N, 2) #l'indice de la matrice à changer
    
        type_old = int(M[i,j,0])   #Au lieu de faire une copie de toute ma matrice avec np.copy, je fais juste une copie de l'élément intéresant
        num_old = int(M[i,j,1]) #L'ancien numéro de la matric

        # choisir un voisin aléatoire
        di, dj = voisins_numero[np.random.randint(0,8)]
        ni, nj = (i + di) % N, (j + dj) % N #Choisir le nouveau voisin, aleatoireemten
        

        type_new = int(M[ni, nj, 0])
        num_new  = int(M[ni, nj, 1])

        if num_new == num_old:
            continue        #Par soucis d'optimisation, on necalcule rien si on ne change rine

        dE_int = dE_surf_local(M, i, j, type_old, num_old, type_new, num_new)                
        dE_vol = dE_volume_local(V_c, V_cible, type_old, num_old, type_new, num_new)
        
        dE = dE_int + dE_vol

        # --- Metropolis ---
        if dE <= 0 or np.random.random() < np.exp(-dE / T):
            # calculer les indices des cellules affectées AVANT de modifier V_c
            if num_old > 0:
                idx_old = (num_old - 1) if (type_old == 1) else (n1 + num_old - 1)
            else:
                idx_old = -1

            if num_new > 0:
                idx_new = (num_new - 1) if (type_new == 1) else (n1 + num_new - 1)
            else:
                idx_new = -1

            # appliquer le changement sur M
            M[i, j, 0] = type_new
            M[i, j, 1] = num_new

            # --- Mise à jour des volumes (in-place) ---
            if idx_old >= 0:
                V_c[idx_old] -= 1
            if idx_new >= 0:
                V_c[idx_new] += 1

    return M, V_c


#%% 


M = np.zeros((N, N, 2), dtype=np.int32)
M = initial_state_smart(M, n1, 1)
M = initial_state_smart(M, n2, 2) 

def def_temp(M, nb_pas):
    M = np.copy(M)
    # summ = np.zeros(nb_pas)
    for i in range(nb_pas):
        increase_temps(M, V_c, N**2)
        # summ[i] = np.sum(M)
        if i % 10 == 0:
            plot_type(M, time = i, cmap = 'inferno')
            # plot_num(M, time = i)
    # plt.plot(np.arange(0,nb_pas, 1), summ)
    # plt.xlabel('temps')
    # plt.ylabel('nombre de pixels 1')
        
def_temp(M, 100001)



#%%

